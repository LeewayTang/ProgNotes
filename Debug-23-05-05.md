> **问题描述**   
目前处理加密视频包的方法是在解包阶段跳过合法性检验（因为测试过程不涉及视频解码）。此阶段调试的目的是确保解码前的相关QoS数据能被正确计算。   
但是`VideoReceiveStream::Stats`中的delay和jitter buffer统计值一直都是0，主要对此进行调试。

# 数据统计路径

WebRTC使用代理类进行视频数据统计

`video/receive_statistics_proxy2.cc: ReceiveStatisticsProxy`

## => OnFrameBufferTimingsUpdated

原型如下：
```cpp
void ReceiveStatisticsProxy::OnFrameBufferTimingsUpdated(
    int max_decode_ms,
    int current_delay_ms,
    int target_delay_ms,
    int jitter_buffer_ms,
    int min_playout_delay_ms,
    int render_delay_ms);

```
被调用的位置是 `modules/video_coding/frame_buffer2.cc: 619`

```cpp

void FrameBuffer::UpdateJitterDelay() {
  TRACE_EVENT0("webrtc", "FrameBuffer::UpdateJitterDelay");
  if (!stats_callback_)
    return;

  int max_decode_ms;
  int current_delay_ms;
  int target_delay_ms;
  int jitter_buffer_ms;
  int min_playout_delay_ms;
  int render_delay_ms;
  if (timing_->GetTimings(&max_decode_ms, &current_delay_ms, &target_delay_ms,
                          &jitter_buffer_ms, &min_playout_delay_ms,
                          &render_delay_ms)) {
    stats_callback_->OnFrameBufferTimingsUpdated(
        max_decode_ms, current_delay_ms, target_delay_ms, jitter_buffer_ms,
        min_playout_delay_ms, render_delay_ms);
  }
}
```
显然，数据源是`VCMTiming::GetTimings`

```cpp
bool VCMTiming::GetTimings(int* max_decode_ms,
                           int* current_delay_ms,
                           int* target_delay_ms,
                           int* jitter_buffer_ms,
                           int* min_playout_delay_ms,
                           int* render_delay_ms) const {
  MutexLock lock(&mutex_);
  *max_decode_ms = RequiredDecodeTimeMs();
  *current_delay_ms = current_delay_ms_;
  *target_delay_ms = TargetDelayInternal();
  *jitter_buffer_ms = jitter_delay_ms_;
  *min_playout_delay_ms = min_playout_delay_ms_;
  *render_delay_ms = render_delay_ms_;
  return (num_decoded_frames_ > 0);
}
```
我们重点关注
- current_delay_ms
- target_delay_ms
- jitter_buffer_ms

### current_delay_ms

由 `VCMTiming::UpdateCurrentDelay`计算得到，这个函数有2个重载

```cpp
void VCMTiming::UpdateCurrentDelay(uint32_t frame_timestamp);
void VCMTiming::UpdateCurrentDelay(int64_t render_time_ms,
                                   int64_t actual_decode_time_ms);
```


**第一个实现**

输入参数：`frame_timestamp` - 视频帧的时间戳。

此实现根据帧的时间戳更新当前的解码延迟。它在每个解码后的帧的时间戳上调用，以确保延迟计算保持最新。这个实现的主要目的是在延迟变化时，使其平滑地增加或减少，避免视频出现显著的卡顿或跳动。

**第二个实现**

输入参数：
- `render_time_ms` - 计划渲染的时间（以毫秒为单位）。
- `actual_decode_time_ms` - 实际解码时间（以毫秒为单位）。

此实现根据实际解码时间和计划渲染时间更新当前的解码延迟。它在解码器完成解码操作后调用，以确定帧是否比预期提前解码。如果提前解码，这个实现会将提前的时间加入到当前延迟中，但不会超过目标延迟。

总之，这两个 `UpdateCurrentDelay` 实现都用于更新解码延迟，但第一个实现关注帧时间戳，使延迟平滑变化，而第二个实现关注实际解码时间和计划渲染时间，以便在提前解码的情况下调整延迟。

因为本测试不关注解码后的内容，所以这个量应该Desperated。

### target_delay_ms

```cpp
int VCMTiming::TargetDelayInternal() const {
  return std::max(min_playout_delay_ms_,
                  jitter_delay_ms_ + RequiredDecodeTimeMs() + render_delay_ms_);
}
```

`TargetDelayInternal()` 函数的目的是计算目标延迟，这是解码器尝试达到的延迟。这个函数并不会在解码后更新，而是在解码过程中被其他函数调用，用于获取目标延迟值。它根据以下参数计算目标延迟：

1. `min_playout_delay_ms_` - 最小播放延迟，这是播放延迟的下限。这个值是从音视频同步来的，即音频数据的时间应该是最小的视频播放延迟（一般音频比视频延迟低）。
2. `jitter_delay_ms_` - 抖动延迟，由网络抖动引起的延迟。
3. `RequiredDecodeTimeMs()` - 解码所需的时间。
4. `render_delay_ms_` - 渲染延迟，渲染帧所需的时间。

### jitter_buffer_ms

```cpp
void VCMTiming::SetJitterDelay(int jitter_delay_ms) {
  MutexLock lock(&mutex_);
  if (jitter_delay_ms != jitter_delay_ms_) {
    jitter_delay_ms_ = jitter_delay_ms;
    // When in initial state, set current delay to minimum delay.
    if (current_delay_ms_ == 0) {
      current_delay_ms_ = jitter_delay_ms_;
    }
  }
}
```
调用位置是

`modules/video_coding/frame_buffer2.cc:293`

```cpp
    timing_->SetJitterDelay(
        jitter_estimator_.GetJitterEstimate(rtt_mult, rtt_mult_add_cap_ms));
```

数据源是`VCMJitterEstimator::GetJitterEstimate`

测试发现 **jitter delay经常被计算为0**

问题出在下面的代码：

```cpp
// int VCMJitterEstimator::GetJitterEstimate(double rttMultiplier,absl::optional<double> rttMultAddCapMs)
// Ignore jitter for very low fps streams.
    if (fps < kJitterScaleLowThreshold) {
      if (fps == 0.0) {
        return rtc::checked_cast<int>(std::max(0.0, jitterMS) + 0.5);
      }
      return 0;
    }
```

当计算得到帧率很低（但是不为0）的时候，就直接将jitter设置为0

帧率的计算来源

```cpp
double VCMJitterEstimator::GetFrameRate() const {
  if (fps_counter_.ComputeMean() <= 0.0)
    return 0;

  double fps = 1000000.0 / fps_counter_.ComputeMean();
  // Sanity check.
  assert(fps >= 0.0);
  if (fps > kMaxFramerateEstimate) {
    fps = kMaxFramerateEstimate;
  }
  return fps;
}

```
<details>
    <summary>jitter buffer fps</summary>
0.000000
0.000000
20.495583
18.341893
15.208663
9.870621
11.121219
7.057744
7.536111
7.084304
7.219290
6.914281
5.877475
4.668550
4.525637
4.415624
4.649705
4.554476
4.403097
4.505917
4.559362
4.563883
4.459068
4.485559
4.447346
4.522920
4.664221
4.473005
4.287301
4.253412
4.221851
4.088154
3.748406
3.622130
3.515041
3.540291
3.281165
3.411027
3.407574
3.411109
3.354067
3.411030
3.503562
3.766170
3.889584
3.893396
3.811817
3.927626
4.087777
4.132240
4.177543
4.251969
4.330000
4.305373
4.386323
4.373198
4.292270
4.523487
4.568565
4.614083
4.781143
4.595546
5.109251
4.636424
4.833145
4.811105
5.290634
5.295713
5.191926
5.275416
5.437311
5.117943
5.183399
5.233006
5.232198
5.180274
5.193098
4.744127
4.632853
4.533277
4.407052
4.206169
4.264566
4.383728
4.367356
4.430239
4.442163
4.469434
4.739671
4.769240
4.560253
4.989329
4.983222
5.837617
5.874770
5.933321
5.932803
5.758625
5.612870
5.656151
5.675029
6.092640
5.992798
5.307885
5.288443
5.473882
4.861301
4.685881
4.800878
4.851755
5.042855
5.054125
4.716005
4.710044
4.751624
4.331335
4.355219
4.355410
4.271122
4.356731
4.362768
4.297171
4.128394
3.813818
3.644245
3.525649
3.487250
3.428762
3.526264
3.468757
3.461574
3.363949
3.246417
3.488924
3.498384
3.517692
3.832460
4.055697
4.052966
4.018001
4.019029
4.067406
4.349439
4.139904
4.087579
4.286409
3.976439
3.749891
3.809512
3.557384
3.628466
3.688937
3.809480
3.986588
4.127297
4.310220
4.314179
4.500544
4.489022
4.422992
4.422893
4.444694
4.694057
4.691395
4.667914
4.600562
4.699184
4.979097
4.589053
4.686637
4.555776
4.728792
4.595868
4.783642
4.735452
4.884127
5.192401
5.152286
4.894373
5.335372
5.312581
5.287061
5.329747
5.475305
5.524603
5.303538
5.497379
5.501508
5.149895
5.216098
5.096455
4.852038
4.848446
4.641582
3.676661
3.749699
3.714012
3.502755
3.693721
3.695111
3.727583
3.525394
3.567498
3.508448
3.582941
3.386701
3.487293
3.697776
3.815043
3.599044
3.605241
3.644188
3.598112
3.577895
3.602458
3.514659
3.463421
3.363030
3.474704
3.386371
3.442934
3.625893
3.670325
3.804827
4.755832
4.641001
4.601010
4.972345
4.913987
4.770654
4.790870
5.193009
4.958620
5.051982
4.974653
4.994109
4.843139
4.764173
4.621317
4.982234
4.976803
4.822863
4.800850
4.919688
4.565332
4.861761
4.817918
5.039417
5.147014
5.378174
5.137512
5.183309
5.185883
5.021302
5.020691
4.427497
4.479319
4.477867
4.375796
4.402067
4.420676
4.233127
4.458619
4.441000
4.460841
4.714042
4.742285
4.745783
4.790939
4.576789
4.677458
4.824966
4.489300
4.251659
4.292775
4.334376
4.431853
4.412669
3.917406
3.955647
3.852012
3.784189
3.763486
3.817355
3.460206
3.683706
3.690807
3.690334
3.625641
3.576188
3.455745
3.548603
3.495539
3.512890
3.533311
3.591888
3.556410
3.573441
3.603677
3.697871
3.695396
3.613554
3.811988
3.999896
4.216103
4.185193
4.125683
4.087237
4.362666
4.416393
4.753777
4.716773
4.650796
4.648842
5.459836
5.808392
5.836921
5.648194
5.749193
5.876033
6.085212
6.085789
6.200788
5.416217
5.131663
5.144917
5.314555
5.285361
5.267023
5.305825
5.076121
5.140165
5.196383
5.024831
4.482002
4.401759
4.456280
4.511371
4.793477
4.676235
4.620126
4.437343
4.301476
4.204206
4.141235
4.177951
4.152695
4.240653
4.448947
4.502100
4.615279
4.559479
4.340379
4.912911
5.197112
5.214542
5.269434
5.327142
5.457979
5.395240
5.601621
5.684779
5.729748
5.945048
6.951475
7.255207
7.310399
6.903301
6.712678
6.945972
6.862843
7.479877
8.225260
6.635404
6.805412
6.692509
6.800744
6.829712
6.781730
6.378013
6.323086
5.888550
6.035134
5.702195
5.732087
5.484797
5.434152
5.410639
5.408387
5.535742
5.570994
5.595220
4.698255
4.710118
4.716934
4.610373
4.568718
4.660980
4.754634
4.640126
4.751522
4.833962
4.818102
5.862336
5.693326
5.752505
5.732252
5.013597
5.050374
5.243984
5.210349
5.692539
5.954503
6.210590
5.958628
6.140066
6.190780
6.274255
6.035175
5.814243
5.787538
5.763681
7.279158
7.095997
6.634808
6.651852
6.598937
6.767136
6.302296
6.305674
6.303965
6.248336
5.370340
5.051348
5.089244
5.017023
4.636852
4.947084
4.949272
4.882720
4.811654
4.810158
4.818153
4.665724
4.621897
4.651652
4.119895
4.076735
4.143242
4.010106
3.664160
3.433188
3.429431
3.467368
3.508056
3.565301
3.545603
3.442053
3.579690
3.443784
3.405687
3.351806
3.675037
3.832514
3.883586
3.904876
4.180484
4.329523
4.240338
4.371567
4.430648
4.354180
4.030978
4.000817
4.084994
4.116664
4.628413
4.441914
4.480242
4.800389
5.238908
5.676765
5.283359
5.110212
4.894892
4.783802
4.852973
5.079969
4.832449
5.146515
5.146794
5.172327
5.158907
4.926381
4.925745
4.823881
4.746751
4.694635
4.719618
4.495227
4.554271
4.400838
4.788025
4.902179
4.758421
4.724421
4.548166
4.797861
4.646757
4.648626
4.275897
4.296923
4.230849
4.262274
4.516963
4.595666
4.531055
4.294668
4.430243
4.488888
4.462682
4.332229
4.269756
4.369072
4.307701
4.392100
4.359268
4.400307
4.477575
4.639067
4.627928
4.859427
4.760330
4.904375
5.020564
5.020596
5.067515
5.067999
5.057134
5.063358
5.784122
5.916232
6.374123
6.060159
6.125009
6.102949
5.580224
5.868107
5.978282
5.995611
6.100132
6.563510
6.340286
6.154583
5.922262
5.631141
5.537536
5.611953
5.606880
5.549135
5.459722
5.367055
5.501091
5.333619
4.842451
4.741993
4.835212
4.611527
4.601814
4.571040
4.551002
4.269158
4.328683
4.587279
4.450588
4.479134
4.910795
4.894964
4.792757
</details>

可以看到有很多低于5的帧率记录，但是实际上在125.6s的样本中共传输了1883帧视频数据，平均帧率在15左右。

# 帧率统计问题

所以现在的问题转向 `VCMJitterEstimator::fps_counter_` 计算帧率异常的原因。

根据上面的代码可以看到，这个counter采集许多样本点，然后根据样本点的平均间距估算接收帧率。以下是counter收到的间隔样本（即收到的每个视频帧之间的时间间隔，单位us）

<details>
<summary>fps_counter_.AddSample</summary>
48895
59905
89106
210964
44307
399566
75192
200218
119524
200673
422611
697769
303075
298397
54050
287812
348311
133566
172148
216086
326491
195156
267117
134140
54052
452533
484636
284532
288814
467004
714108
339212
339769
148385
713747
52522
87521
191510
265742
51448
193490
101076
50239
289753
219993
56071
47551
55222
93602
89053
199231
236000
138016
156916
181289
95786
419764
220089
59229
722670
57383
938150
77006
175730
148400
47000
200395
99002
98718
394600
118789
46833
50339
347136
207134
601536
200446
197489
283203
415160
102312
42245
164553
57706
165006
54184
37020
180953
348351
155794
64890
56955
44857
125469
148554
199639
336419
58728
80084
32087
200271
694031
70689
156122
896313
832849
47235
131904
48928
400091
529287
51009
109775
668945
126741
54156
172819
43159
338230
261117
350716
656050
410716
399739
244953
346384
95175
199900
97928
283284
522548
52116
48206
107774
195067
400845
54201
196205
47948
311086
50272
400629
200009
330786
673235
508725
48336
601700
171392
126648
92973
306972
153208
94277
235674
58901
110959
301197
96820
251015
165034
54132
79957
202683
59300
43045
564131
60013
230797
71667
232948
145526
264571
136102
308007
554720
355482
93279
196851
153647
47235
156942
105634
319801
37802
54324
483118
225709
233003
547019
169836
330068
1776290
43682
134981
531502
121760
56797
159678
533319
132898
285929
86969
622189
52404
65082
104852
567132
181962
64755
152836
203753
48130
528178
162651
312284
198059
450878
87685
107408
69724
41032
199445
199730
192383
43378
193211
240380
133591
48804
405176
174030
179564
599167
239221
167647
299431
96614
188560
256926
181803
52819
521743
127461
219300
39304
72323
200084
349337
55803
66720
230503
200548
1001155
112224
46137
349673
198422
104703
349818
46168
200412
152346
236463
200338
163484
240607
389653
48011
61140
646036
427342
453071
60159
66900
68690
932021
126557
552869
195362
110373
118043
1011601
473549
99481
47206
493481
314262
396823
121837
175438
158284
100218
99128
284857
122803
169673
176396
53212
246647
213208
56798
69417
112690
170262
136300
469871
42837
70893
244745
200795
120723
53349
143240
74192
218268
399820
199955
224175
121343
84045
859034
407830
83478
99780
153836
188538
135694
309354
171318
150021
254961
793049
233584
86959
55333
77292
198476
148801
513317
414375
282083
161646
81060
116368
68256
70063
121578
58580
199545
417507
53988
73410
64513
38498
92528
53648
200452
103011
93093
110664
64127
61911
54221
55532
297025
199855
51555
200011
150583
51180
1155862
48020
155054
47522
49153
102945
400709
99095
550013
292844
344006
45952
300384
90824
115712
56384
71891
70014
69519
1132412
49405
52391
199860
115836
167353
74105
205182
49592
44029
71242
47057
200145
99330
50146
801116
54771
197136
138208
63286
60751
136156
251074
151685
50102
51033
246457
260561
93827
89868
51567
154726
345573
189425
151173
55152
400629
201709
51119
85922
856568
400739
156151
186061
553081
393944
54331
265409
227108
64763
51386
339789
309901
110480
882427
129009
128237
502085
799635
641039
59578
58286
246204
52129
199250
307492
65989
534089
147221
228564
69039
64321
52943
143883
47846
147016
200256
53277
134874
183850
599736
399102
156752
53808
75309
399663
72743
54639
277523
200520
451633
251192
503121
195646
108921
32306
368330
154684
147559
200026
83278
339009
55451
271150
148567
219165
164855
370390
48936
412885
51936
251421
339151
100596
321552
59148
272272
52087
839577
164870
562554
199145
107506
81565
200473
397300
154383
66155
186880
400039
187191
179357
152097
138103
200153
153903
47228
137525
64578
104518
180269
64240
200585
99420
266795
59085
284909
44579
101503
50324
196990
442854
55167
98772
661500
133454
60320
51746
101532
55230
346185
320910
343917
400555
289392
80174
55908
192082
152146
198533
46108
235145
770199
230306
145285
357097
301196
89005
129926
485050
100913
51920
256219
55163
73574
153289
190756
</details>

只有577个样本点，显然不合理。

根据帧率15来看，样本间隔应该在66667us这个量级。

调用栈是

```
--- EstimateRandomJitter
-- UpdateEstimate
- FrameBuffer::GetNextFrame
```

FrameBuffer共计插入1883帧，但是GetNextFrame仅调用579次。

# 修改
因为FrameBuffer相关的过程不好改动，所以最终将低帧率延迟补偿的部分去掉了。
```cpp
// Returns the current filtered estimate if available,
// otherwise tries to calculate an estimate.
int VCMJitterEstimator::GetJitterEstimate(
    double rttMultiplier,
    absl::optional<double> rttMultAddCapMs) {
  double jitterMS = CalculateEstimate() + OPERATING_SYSTEM_JITTER;
  uint64_t now = clock_->TimeInMicroseconds();

  if (now - _latestNackTimestamp > kNackCountTimeoutMs * 1000)
    _nackCount = 0;

  if (_filterJitterEstimate > jitterMS)
    jitterMS = _filterJitterEstimate;
  if (_nackCount >= _nackLimit) {
    if (rttMultAddCapMs.has_value()) {
      jitterMS +=
          std::min(_rttFilter.RttMs() * rttMultiplier, rttMultAddCapMs.value());
    } else {
      jitterMS += _rttFilter.RttMs() * rttMultiplier;
    }
  }
/* 出于测试目的，去掉低帧率补偿
  if (enable_reduced_delay_) {
    static const double kJitterScaleLowThreshold = 5.0;
    static const double kJitterScaleHighThreshold = 10.0;
    double fps = GetFrameRate();
    // Ignore jitter for very low fps streams.
    if (fps < kJitterScaleLowThreshold) {
      if (fps == 0.0) {
        return rtc::checked_cast<int>(std::max(0.0, jitterMS) + 0.5);
      }
      return 0;
    }

    // Semi-low frame rate; scale by factor linearly interpolated from 0.0 at
    // kJitterScaleLowThreshold to 1.0 at kJitterScaleHighThreshold.
    if (fps < kJitterScaleHighThreshold) {
      jitterMS =
          (1.0 / (kJitterScaleHighThreshold - kJitterScaleLowThreshold)) *
          (fps - kJitterScaleLowThreshold) * jitterMS;
    }
  }
*/
  return rtc::checked_cast<int>(std::max(0.0, jitterMS) + 0.5);
}
```